//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "StaticGlobalPlanner.hh"
#include "ComponentWebotsPlanner.hh"

#include <iostream>

StaticGlobalPlanner::StaticGlobalPlanner(SmartACE::SmartComponent *comp) :	
StaticGlobalPlannerCore(comp), 
replan(false)
{
	auto box = COMP->getGlobalState().getRobot().getFootprint();
	std::vector<double> v_box;
	for (auto& b : box)
		v_box.push_back(b);
	robot_footprint = Eigen::AlignedBox2d(
		Eigen::Vector2d(v_box[0], v_box[1]), Eigen::Vector2d(v_box[2], v_box[3]));
	space = std::make_shared<ompl::base::SE2StateSpace>();
	simple_setup_ = std::make_shared<ompl::geometric::SimpleSetup>(space);
}

StaticGlobalPlanner::~StaticGlobalPlanner() 
{
}

void StaticGlobalPlanner::BaseStateServiceIn(const CommBasicObjects::CommBaseState &input)
{
	robot_pose = input;
}

void StaticGlobalPlanner::ObstaclesServiceIn(
		const CommNavigationObjects::BoundingBoxes &input) {
	sample_space = input.getFloor();
	
	ompl::base::RealVectorBounds bounds(2);
	bounds.setLow(0, std::min(sample_space.getXmin(), sample_space.getXmax()));
	bounds.setLow(1, std::min(sample_space.getZmin(), sample_space.getZmax()));
	bounds.setHigh(0, std::max(sample_space.getXmax(), sample_space.getXmin()));
	bounds.setHigh(1, std::max(sample_space.getZmin(), sample_space.getZmax()));
	space->setBounds(bounds);

	auto boxes = input.getBoxesCopy();
	for (auto& box : boxes) {
		Eigen::Vector2d _min(
			std::min(box.getXmin(), box.getXmax()),
			std::min(box.getZmin(), box.getZmax()));
		Eigen::Vector2d _max(
			std::max(box.getXmin(), box.getXmax()),
			std::max(box.getZmin(), box.getZmax()));	 
		obstacles.push_back(Eigen::AlignedBox2d(_min, _max));
	}

	validity_checker = std::make_shared<BoundingBoxValidityChecker>(
		simple_setup_->getSpaceInformation(), obstacles, robot_footprint);
	simple_setup_->setStateValidityChecker(validity_checker);
	obstacles_init = true;
}

void StaticGlobalPlanner::PlannerGoalServiceIn(
		const CommNavigationObjects::CommPlannerGoal &input) {
	if (input.getXGoalPoint() == goal.getXGoalPoint() && 
			input.getYGoalPoint() == goal.getYGoalPoint() && !replan)
		return;
	if (validity_checker) {
		goal = input;
		ompl::base::ScopedState<ompl::base::SE2StateSpace> start(space);
		ompl::base::ScopedState<ompl::base::SE2StateSpace> end(space);
		start->setXY(robot_pose.get_base_position().get_x(1), 
			- robot_pose.get_base_position().get_y(1));
		end->setXY(input.getXGoalPoint(), input.getYGoalPoint());
		simple_setup_->setStartAndGoalStates(start, end);
		ompl::base::PlannerStatus solved = simple_setup_->solve(1.0);
		if (solved) {
        simple_setup_->simplifySolution();
        simple_setup_->getSolutionPath().print(std::cout);
		}
	}
}

int StaticGlobalPlanner::on_entry()
{
	return 0;
}

int StaticGlobalPlanner::on_execute()
{
  COMP->mRobotMutex.acquire();
	CommNavigationObjects::BoundingBoxes objs;
  Smart::StatusCode obj_status = obstaclesServiceInGetUpdate(objs);
  if (obj_status == Smart::SMART_OK) {
		obstacles_init = false;
		ObstaclesServiceIn(objs);
	}
	if (!obstacles_init) {
		COMP->mRobotMutex.release();
		return 0;
	}
	
	CommBasicObjects::CommBaseState base;
	Smart::StatusCode base_status = baseStateServiceInGetUpdate(base);
	if (base_status != Smart::SMART_OK) {
		COMP->mRobotMutex.release();
		return 0;
	}
	BaseStateServiceIn(base);

	CommNavigationObjects::CommPlannerGoal goal_;
	goal_.setXGoalPoint(1.6);
	goal_.setYGoalPoint(7.76);
	PlannerGoalServiceIn(goal_);
  COMP->mRobotMutex.release();
	return 0;
}
int StaticGlobalPlanner::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

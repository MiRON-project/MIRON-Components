//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "MapObstacleUpdate.hh"
#include "ComponentWebotsPlanner.hh"

#include <iostream>

MapObstacleUpdate::MapObstacleUpdate(SmartACE::SmartComponent *comp) 
:	MapObstacleUpdateCore(comp)
{
	std::cout << "constructor MapObstacleUpdate\n";
}
MapObstacleUpdate::~MapObstacleUpdate() 
{
	std::cout << "destructor MapObstacleUpdate\n";
}


void MapObstacleUpdate::on_ObjectsPushServiceIn(
	const CommObjectRecognitionObjects::CommObjectRecognitionEnvironment &input)
{
	// upcall triggered from InputPort ObjectsPushServiceIn
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort ObjectsPushServiceIn
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method objectsPushServiceInGetUpdate(input) to get a copy of the input object
}

int MapObstacleUpdate::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}
int MapObstacleUpdate::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	// to get the incoming data, use this methods:
	Smart::StatusCode status;
	CommObjectRecognitionObjects::CommObjectRecognitionEnvironment objectsPushServiceInObject;
	status = this->objectsPushServiceInGetUpdate(objectsPushServiceInObject);
	if(status != Smart::SMART_OK) {
		std::cerr << status << std::endl;
	} else {
		updateDynamicObstacles(objectsPushServiceInObject);
		updatePedestrianChecker();
	}

	return 0;
}

void MapObstacleUpdate::updateDynamicObstacles(
	const CommObjectRecognitionObjects::CommObjectRecognitionEnvironment& objects) 
{
	auto dist = [](const CommBasicObjects::CommPose3d& pose_1, 
								 const CommBasicObjects::CommPose3d& pose_2)
	{
		return sqrt(pow(pose_1.get_x(1) - pose_2.get_x(1), 2) +
								pow(pose_1.get_y(1) - pose_2.get_y(1), 2));
	};

	for (auto& object : objects.getObjectsCopy()) {
		bool found = false;
		for (auto& object_ : dynamic_objects_) {
			if (object.getObject_id() == object_.property.getObject_id()) {
				found = true;
				auto object_pose = object.getPose();
				auto object_pose_ = object_.property.getPose();
				if (dist(object_pose, object_pose_) > 0.001) {
					object_.changed = true;
					object_.property = object;
				}
				break;
			}
		}
		if (!found) {
			DynamicObject object_;
			object_.property = object;
			object_.changed = true;
			dynamic_objects_.push_back(object_);
		}
	}
}

void MapObstacleUpdate::updatePedestrianChecker() {
	COMP->validity_checker_Mutex.acquire();
	if (!COMP->validity_checker) {
		COMP->validity_checker_Mutex.release();
		return;
	}

	auto make_pedestrian_box = [](const CommBasicObjects::CommPose3d& pose) {
		return Eigen::AlignedBox2d(
						Eigen::Vector2d(pose.get_x(1) - 0.4, -pose.get_y(1) - 0.4), 
						Eigen::Vector2d(pose.get_x(1) + 0.4, -pose.get_y(1) + 0.4));
	};

	for (auto& object_ : dynamic_objects_) {
		if (object_.changed && object_.property.getObject_type() == "pedestrian") 
		{
			bool found = false;
			for (auto& valid_object : COMP->validity_checker->dynamic_obstacles) {
				if (valid_object.first == object_.property.getObject_id()) {
					valid_object.second = make_pedestrian_box(object_.property.getPose());
					found = true;
					object_.changed = false;
					break;
				}
			}
			if (!found) {
				COMP->validity_checker->dynamic_obstacles.push_back(
					std::make_pair(object_.property.getObject_id(),
												 make_pedestrian_box(object_.property.getPose())));
				object_.changed = false;
			}	
		}
	}
	COMP->validity_checker_Mutex.release();
}

int MapObstacleUpdate::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "SupervisorTask.hh"
#include "ComponentWebotsRobot.hh"

#include <iostream>

std::unordered_map<std::string, std::string> SupervisorTask::objects_names = {
	{"WOODENBOX","WoodenBox"}
};

SupervisorTask::SupervisorTask(SmartACE::SmartComponent *comp) 
:	SupervisorTaskCore(comp),
	object_offset({0,0,0})
{}
SupervisorTask::~SupervisorTask() 
{}

void SupervisorTask::on_ObjectDropPushServiceIn(
		const DomainSpeech::CommObjectDropOutputMessage &input){
  COMP->mRobotMutex.acquire();
  
	int index = input.getObj_carried_index();
	if (index < -1) {
		COMP->mRobotMutex.release();
		return;
	}
	else if (index == -1) {
		for (auto& obj : carried_obj_index) {
			if (obj > index)
				index = obj;
		}
	}
	else {
		bool found = false;
		for (auto& obj : carried_obj_index) {
			if (obj == index)
				found = true;
				break;
		}
		if (!found) {
			COMP->mRobotMutex.release();
			return;
		}
	}

	webots::Node *root = COMP->_supervisor->getRoot();
  auto children = root->getField("children");
	children->removeMF(index);
	int index_to_remove = -2;
	for (size_t i = 0; i < carried_obj_index.size(); ++i) {
		if (carried_obj_index[i] > index)
			carried_obj_index[i]-=1;
		else if (carried_obj_index[i] == index)
			index_to_remove = i;
	}
	if (index_to_remove != -2)
		carried_obj_index.erase(carried_obj_index.begin()+index_to_remove);
	
	COMP->mRobotMutex.release();
}

void SupervisorTask::on_ObjectPlacementPushServiceIn(
		const DomainSpeech::CommObjectPlacementOutputMessage &input)
{
  COMP->mRobotMutex.acquire();
	
	std::string type = objects_names[input.getObjectType()];
	if (type == "") {
		COMP->mRobotMutex.release();
		return;
	}

	std::vector<std::string> sizes;
	for (size_t i = 0; i < input.getObjectSizeSize(); ++i) {
		if (input.getObjectSizeElemAtPos(i) > object_max_size)	
			return;
		sizes.push_back(std::to_string(input.getObjectSizeElemAtPos(i)));
	}
	std::array<std::string, 3> robot_position = {
      std::to_string(COMP->_pose->get_base_position().get_x(1) + object_offset[0]),
      std::to_string(object_offset[1]),
      std::to_string(-COMP->_pose->get_base_position().get_y(1) + object_offset[2])
			};

	std::string obj = type + " {" + "translation " + robot_position[0] + " " +
		robot_position[1] + " " + robot_position[2] + " size ";
	
	for (auto& s : sizes)
		obj += s + " "; 
	obj += "mass " + std::to_string(input.getObjectMass()) + "}";
	
	webots::Node *root = COMP->_supervisor->getRoot();
  auto children = root->getField("children");
  children->importMFNodeFromString(-1, obj);
  carried_obj_index.push_back(children->getCount() - 1);

  COMP->mRobotMutex.release();
}

int SupervisorTask::on_entry()
{
  COMP->mRobotMutex.acquire();
	auto obstacles = extractStaticObstacles();
	object_max_size = COMP->getGlobalState().getHri().
    getMax_size();
	auto offset = COMP->getGlobalState().getHri().getOffset();
	object_offset.clear();
	for (auto o : offset)
		object_offset.push_back(o);
  COMP->mRobotMutex.release();
	return 0;
}
int SupervisorTask::on_execute()
{
	return 0;
}
int SupervisorTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

CommNavigationObjects::BoundingBoxes SupervisorTask::extractStaticObstacles() {
	CommNavigationObjects::BoundingBoxes bounding_boxes;
	std::vector<CommNavigationObjects::BoundingBox> boxes;

	webots::Node *root = COMP->_supervisor->getRoot();
  auto children = root->getField("children");
	size_t number_of_nodes = children->getCount();
	for (size_t i = 0; i < number_of_nodes; ++i)
	{
		auto node = children->getMFNode(i);
		if (node->getTypeName() == "Floor" && 
			node->getField("name")->getSFString() == "floor") {
			bounding_boxes.setFloor(webotsNodeSize2DToBoundingBox(node));
		}
		else if (node->getTypeName() == "OilBarrel") {
			boxes.push_back(webotsNodeCylinderToBoundingBox(node));
		}
		else if (node->getTypeName() == "Door" ||
						 node->getTypeName() == "WoodenPallet" ||
						 node->getTypeName() == "Table" ||
						 node->getTypeName() == "CardboardBox" ||
						 node->getTypeName() == "Wall" || 
						 node->getTypeName() == "WoodenBox") {
			boxes.push_back(webotsNodeSize3DToBoundingBox(node));
		}
		else if (node->getTypeName() == "WoodenPalletStack") {
			boxes.push_back(webotsPalletToBoundingBox(node));
		}
		else if (node->getTypeName() == "Cabinet") {
			boxes.push_back(webotsCabinetToBoundingBox(node));
		}
	}
	bounding_boxes.setBoxes(boxes);
	return bounding_boxes;
}

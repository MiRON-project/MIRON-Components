//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "SupervisorTask.hh"
#include "ComponentWebotsRobot.hh"

#include <iostream>

std::unordered_map<std::string, std::string> SupervisorTask::objects_names = {
		{"WOODENBOX", "WoodenBox"},
		{"MOCK", "mock"}};

SupervisorTask::SupervisorTask(SmartACE::SmartComponent *comp)
		: SupervisorTaskCore(comp),
			object_offset({0, 0, 0}),
			robot_payload_(RobotPayload())
{}

SupervisorTask::~SupervisorTask()
{}

void SupervisorTask::on_ObjectDropPushServiceIn(
		const DomainSpeech::CommObjectDropOutputMessage &input)
{
	COMP->mRobotMutex.acquire();

	int index = input.getObj_carried_index();
	if (index < -1)
	{
		COMP->mRobotMutex.release();
		return;
	}
	else if (index == -1)
	{
		for (auto &obj : carried_obj_index_mass)
		{
			if (obj.first > index)
				index = obj.first;
		}
	}
	else
	{
		bool found = false;
		for (auto &obj : carried_obj_index_mass)
		{
			if (obj.first == index)
				found = true;
			break;
		}
		if (!found)
		{
			COMP->mRobotMutex.release();
			return;
		}
	}

	webots::Node *root = COMP->_supervisor->getRoot();
	auto children = root->getField("children");
	children->removeMF(index);
	int index_to_remove = -2;
	for (size_t i = 0; i < carried_obj_index_mass.size(); ++i)
	{
		if (carried_obj_index_mass[i].first > index)
			carried_obj_index_mass[i].first -= 1;
		else if (carried_obj_index_mass[i].first == index)
			index_to_remove = i;
	}
	if (index_to_remove != -2)
	{
		robot_payload_.AddItem(-carried_obj_index_mass[index_to_remove].second);
		carried_obj_index_mass.erase(carried_obj_index_mass.begin() +
																 index_to_remove);
	}
	COMP->mRobotMutex.release();
}

void SupervisorTask::on_ObjectPlacementPushServiceIn(
		const DomainSpeech::CommObjectPlacementOutputMessage &input)
{
	COMP->mRobotMutex.acquire();

	std::string type = objects_names[input.getObjectType()];
	if (type == "")
	{
		COMP->mRobotMutex.release();
		return;
	}

	if (type == "mock") 
	{
		carried_obj_index_mass.push_back(std::make_pair(-10, input.getObjectMass()));
		robot_payload_.AddItem(input.getObjectMass());
		COMP->mRobotMutex.release();
		return;
	}

	std::vector<std::string> sizes;
	for (size_t i = 0; i < input.getObjectSizeSize(); ++i)
	{
		if (input.getObjectSizeElemAtPos(i) > object_max_size)
			return;
		sizes.push_back(std::to_string(input.getObjectSizeElemAtPos(i)));
	}
	std::array<std::string, 3> robot_position = {
			std::to_string(COMP->_pose->get_base_position().get_x(1) + 
				object_offset[0]),
			std::to_string(object_offset[1]),
			std::to_string(-COMP->_pose->get_base_position().get_y(1) + 
				object_offset[2])};

	std::string obj = type + " {" + "translation " + robot_position[0] + " " +
										robot_position[1] + " " + robot_position[2] + " size ";

	for (auto &s : sizes)
		obj += s + " ";
	obj += "mass " + std::to_string(input.getObjectMass()) + "}";

	webots::Node *root = COMP->_supervisor->getRoot();
	auto children = root->getField("children");
	children->importMFNodeFromString(-1, obj);
	carried_obj_index_mass.push_back(std::make_pair(children->getCount() - 1,
																									input.getObjectMass()));
	robot_payload_.AddItem(input.getObjectMass());

	COMP->mRobotMutex.release();
}

int SupervisorTask::on_entry()
{
	COMP->mRobotMutex.acquire();
  if (!COMP->_supervisor) {
    COMP->mRobotMutex.release();
    return -1;
  }

  robot_payload_.max_number_items_ = COMP->getParameters().
		getRobot_properties().getPayload_max_items();
	robot_payload_.max_mass_ = COMP->getParameters().
		getRobot_properties().getPayload_max_mass();
	obstacles = extractStaticObstacles();
	object_max_size = COMP->getParameters().getHri().getMax_size();
	auto offset = COMP->getParameters().getHri().getOffset();
	object_offset.clear();
	for (auto o : offset)
		object_offset.push_back(o);
	COMP->mRobotMutex.release();
	return 0;
}
int SupervisorTask::on_execute()
{
	COMP->mRobotMutex.acquire();

	obstaclesServiceOutPut(obstacles);

	CommBasicObjects::RobotPayload robot_payload;
	robot_payload.setMass(robot_payload_.mass_);
	robot_payload.setNumber_of_items(robot_payload_.number_of_items_);
	robot_payload.setFull(robot_payload_.full_);
	payloadServiceOutPut(robot_payload);
	COMP->mRobotMutex.release();
	return 0;
}
int SupervisorTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

CommNavigationObjects::BoundingBoxes SupervisorTask::extractStaticObstacles()
{
	CommNavigationObjects::BoundingBoxes bounding_boxes;
	std::vector<CommNavigationObjects::BoundingBox> boxes;

	webots::Node *root = COMP->_supervisor->getRoot();
	auto children = root->getField("children");
	size_t number_of_nodes = children->getCount();
	for (size_t i = 0; i < number_of_nodes; ++i)
	{
		auto node = children->getMFNode(i);
		if (node->getTypeName() == "Floor" &&
				node->getField("name")->getSFString() == "floor")
		{
			bounding_boxes.setFloor(webotsNodeSize2DToBoundingBox(node));
		}
		else if (node->getTypeName() == "OilBarrel")
		{
			boxes.push_back(webotsNodeCylinderToBoundingBox(node));
		}
		else if (node->getTypeName() == "Door" ||
						 node->getTypeName() == "WoodenPallet" ||
						 node->getTypeName() == "Table" ||
						 node->getTypeName() == "CardboardBox" ||
						 node->getTypeName() == "Wall" ||
						 node->getTypeName() == "WoodenBox")
		{
			boxes.push_back(webotsNodeSize3DToBoundingBox(node));
		}
		else if (node->getTypeName() == "WoodenPalletStack")
		{
			boxes.push_back(webotsPalletToBoundingBox(node));
		}
		else if (node->getTypeName() == "Cabinet")
		{
			boxes.push_back(webotsCabinetToBoundingBox(node));
		}
	}
	bounding_boxes.setBoxes(boxes);
	return bounding_boxes;
}
